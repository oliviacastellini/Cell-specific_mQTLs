---
title: "Replication of mQTLs associations across contexts"
author: Olivia Castellini-PÃ©rez
date: August 9, 2023
abstract: ""
output:  
  bookdown::pdf_book:
  keep_tex: true
fig_caption: yes
toc: true
---
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Models 

(1) n=all, data=bulk, model=interaction, cell-type=x4(salas), region=cis, cell-count=predicted
(2) n=all, data=bulk, model=interaction, cell-type=x4(salas), region=cis, cell-count=observed
(3) n=all, data=cell-specific, model=main, cell-type=x4(sorted), region=cis
(4) n=overlap(~60), data=cell-specific, model=main, cell-type=x4(sorted), region=cis
(5) n=overlap(~60), data=bulk, model=interaction, cell-type=x4(the same as sorted), region=cis

# Samples
```{r, include=FALSE}
library(readxl)
table1<-read_excel("/user/home/uy23281/scratch/rmd.results/Table1_Samples.xlsx",col_names = T)
table1<-as.data.frame(table1)
```

```{r table1, echo=FALSE}
knitr::kable(table1,format="latex",digits=400,booktabs = T,align="c")
```
  
# Replication
  
  1. Are the GoDMC SNP-CpG pairs replicating in bulk+int?
  2. Are the GoDMC SNP-CpG pairs replicating in cell-specific? 
  3. Discovery in bulk+int replicating in cell-specific?  
  4. Discovery in cell-specific replicating in bulk?
  
## GoDMC SNP-CpG pairs replication
  
```{r, include=FALSE}
library(dplyr)
library(data.table)
library(tidyr)
library(ggplot2)
library(gridExtra)
library(epiR)
library(stats)
library(car)
```

```{r, include=FALSE}
standardise <- function(d, ea="ea", oa="oa", beta="beta", chr="chr", pos="pos") {
  toflip <- d[[ea]] > d[[oa]]
  d[[beta]][toflip] <- d[[beta]][toflip] * -1
  temp <- d[[oa]][toflip]
  d[[oa]][toflip] <- d[[ea]][toflip]
  d[[ea]][toflip] <- temp
  d[["snpid"]] <- paste0(d[[chr]], ":", d[[pos]], "_", toupper(d[[ea]]), "_", toupper(d[[oa]]))
  d
}

repl_obs_exp <- function(b_disc, b_rep, se_disc, se_rep, alpha) {
  p_sign <- pnorm(-abs(b_disc) / se_disc) * pnorm(-abs(b_disc) / se_rep) + ((1 - pnorm(-abs(b_disc) / se_disc)) * (1 - pnorm(-abs(b_disc) / se_rep)))
  p_sig <- pnorm(-abs(b_disc) / se_rep + qnorm(alpha / 2)) + (1 - pnorm(-abs(b_disc) / se_rep - qnorm(alpha / 2)))
  p_rep <- pnorm(abs(b_rep)/se_rep, lower.tail=FALSE)
  res <- tibble::tibble(
    nsnp=length(b_disc),
    metric=c("Sign", "Sign", "P-value", "P-value"),
    datum=c("Expected", "Observed", "Expected", "Observed"),
    value=c(sum(p_sign, na.rm=TRUE), sum(sign(b_disc) == sign(b_rep)), sum(p_sig, na.rm=TRUE), sum(p_rep < alpha, na.rm=TRUE))
  )
  return(list(res=res, variants=dplyr::tibble(sig=p_sig, sign=p_sign)))
}

# Read in clumped
load("/user/home/uy23281/scratch/16_clumped.rdata")

# Organise data
clumped <- ungroup(clumped)
clumped$snpchr <- gsub("chr", "", clumped$snpchr)
clumped2 <- standardise(clumped, "Allele2", "Allele1", "Effect", "snpchr", "snppos")

```

# Results
## Replication between model 1 (interaction model with predicted cell counts) and model 2 (interaction model with observed cell counts)
```{r, include=FALSE}
cell_types<-c("neu","mono","tcell","bcell")

# Initialize empty lists to store results
correlation_results <- vector("numeric", length(cell_types))
ccc_results <- vector("numeric", length(cell_types))
significant_overlap <- vector("numeric", length(cell_types))
plots_list <- list()
results_list <- list() # Create a list to store the results for each chunk

# Loop through each chunk (replace `chunk1_data`, `chunk2_data`, etc. with your actual data frames)
for (i in 1:length(cell_types)) {
for (n in 1:7) {
  # Replace `chunki_data` with your actual data frame for the current chunk
  current_chunk<-read.table(paste0("/user/home/uy23281/scratch/rmd.results/model2/",cell_types[i],"/res.cis.", n, ".gz"),header=T)
  current_chunk$p.value<-as.numeric(as.character(current_chunk$p.value))
  # Group the data by 'cpg' and select the row with the lowest p-value in each group
 result <- current_chunk %>%
  group_by(SNP) %>%
  arrange(gene, SNP, p.value) %>%
  slice_min(order_by = p.value)
  
  # Store the result in the list
  results_list[[n]] <- result
}

model2_merged <- bind_rows(results_list)
model2_merged$beta<-as.numeric(as.character(model2_merged$beta))
model2_merged$SNP_cpg<-paste0(model2_merged$SNP,"_",model2_merged$gene)

# Extract data for the current cell type from model 1
  for (n in 1:7) {
    model1<-read.table(paste0("/user/home/uy23281/scratch/rmd.results/model1/",cell_types[i],"/res.cis.", n, ".gz"))
    if (n == 1) {
      model1_merged <- model1
    } else {
      model1_merged <- rbind(model1_merged, model1)
    }
  }
model1_merged<-model1_merged[-1,]
colnames(model1_merged)<-c("SNP","cpg","beta","t","P","FDR")
model1_merged$beta<-as.numeric(as.character(model1_merged$beta))

#Extract same hit model1-SNP_cpg pairs from model1 
model1_merged$SNP_cpg<-paste0(model1_merged$SNP,"_",model1_merged$cpg)
model1_merged<-model1_merged[which(model1_merged$SNP_cpg %in% model2_merged$SNP_cpg),]
  
    # Perform correlation analysis
    correlation_results[i] <- cor(model1_merged$beta,model2_merged$beta)
    
    # Perform concordance analysis
    ccc <- epi.ccc(model1_merged$beta, model2_merged$beta)
    ccc_results[i] <- ccc$rho.c
    
    # Count overlapping significant mQTLs
    significant_overlap[i] <- sum(model1_merged$`p-value` < 0.05 & model2_merged$`p-value` < 0.05)
    
    # Plot
    model1_merged<-model1_merged[order(model1_merged$`p-value`),]
    model2_merged<-model2_merged[order(model2_merged$`p-value`),]
    subset_m1<-model1_merged[1:10000,]
    subset_m2<-model2_merged[1:10000,]
    
plot1<-plot(subset_m1$beta, subset_m2$beta, xlab = paste0("Model 1 Effect Size (",cell_types[i],")"), ylab = paste0("Model 2 Effect Size (",cell_types[i],")"))
abline(a = 0, b = 1, col = "red")

plots_list[[n]] <- plot1
}
# Create data frames to store the results
correlation_df <- data.frame(Cell_Type = cell_types, Correlation = correlation_results)
ccc_df <- data.frame(Cell_Type = cell_types, CCC = ccc_results)
overlap_df <- data.frame(Cell_Type = cell_types, Significant_Overlap = significant_overlap)

#Save the plot 
grid_plots <- grid.arrange(grobs = plots_list, ncol = 2, nrow = 2)
ggsave(filename = "/user/home/uy23281/scratch/rmd.results/model1/Effect_plot_m1vsm2.png", plot = grid_plots)
```

### Correlation 
```{r correlation_df, echo=FALSE}
print(correlation_df)
```

### Concordance analysis  
```{r ccc_df, echo=FALSE}
print(ccc_df)
```

### Overlapping significant mQTLs  
```{r significant_overlap, echo=FALSE}
print(significant_overlap)
```

### Plots
```{r plot1, out.width="80%", fig.align="center",fig.cap=c("Model 1 effect versus model 2 effect"), echo=FALSE}
knitr::include_graphics("/user/home/uy23281/scratch/rmd.results/model1/Effect_plot_m1vsm2.png")

```

## Relationship between GoDMC and model 4 (cell-sorted model) effects
```{r, include=FALSE}
##Loop to read and process all 100 chunks 
# Initialize an empty data frame to store the results
merged_data <- data.frame()
cell.list<-c("neu","mono","tcell","bcell")
#Create an empty list to store data frames and plots 
results_list <- list()
plots_list <- list()
prop_table_list <- list()
repl_list <- list()
#Loop through cell types
for (n in 1:length(cell.list)){
  # Read standard deviation file 
  sds<-read.table(paste0("/user/home/uy23281/scratch/rmd.results/model4/",cell.list[n],"/sd.methy.txt"),header=T,sep="\t")
  # Loop through 7 chunks of cell data
  for (i in 1:7) {
    # Read in the current chunk
    chunk_file <- paste0("/user/home/uy23281/scratch/rmd.results/model4/",cell.list[n],"/res.cis.", i, ".gz")
    cell <- fread(chunk_file)
    cell <- left_join(cell, sds, by = c("gene" = "cpg"))
    
    # Subset the current chunk based on the clumped$cpg values
    cell <- subset(cell, gene %in% clumped$cpg)
    
    # Separate SNP column into chr and pos
    cell <- cell  %>% tidyr::separate(SNP, sep = ":", into = c("chr", "pos"))
    
    # Separate pos column into pos, a1, and a2
    cell <- cell %>% tidyr::separate(pos, sep = "_", into = c("pos", "a1", "a2"))
    
    # Standardize cell data
    cell2 <- standardise(cell, "a1", "a2", "beta", "chr", "pos")
    
    # Merge with clumped2 data
    m <- inner_join(clumped2, cell2, by = c("snpid", "cpg" = "gene"))
    
    # Calculate standard error
    m$se <- m$beta / m$`t-stat`
    m$se_std<-m$se/m$sd
    m$beta_std<-m$beta/m$sd
    
    # Append the current chunk's data to the merged_data
    if (i == 1) {
      merged_data <- m
    } else {
      merged_data <- rbind(merged_data, m)
    }
  }
  # 1 Relationship between the effects
  full <- lm(Effect ~ beta_std, data = merged_data)
  fitted <- summary(full)$coefficients
  result_df <- data.frame(CellType = cell.list[n], Beta = fitted[2, 1], SE = fitted[2, 2],
                          PValue = fitted[2, 4])
  
  #2 Overall replication rate
  prop_table <- table(merged_data$`p-value` < 0.05) %>% prop.table()
  prop_table_df <- data.frame(CellType = cell.list[n], PropTable = prop_table)
  
  #3 Replication rate 
  repl <- repl_obs_exp(merged_data$Effect, merged_data$beta_std, merged_data$StdErr, merged_data$se_std, 5e-6)
  repl<-as.data.frame(repl$res)
  repl_df <- data.frame(CellType = cell.list[n], Repl = repl)
  
  #Save the different data frames 
  results_list[[n]] <- result_df
  prop_table_list[[n]] <- prop_table_df
  repl_list[[n]] <- repl_df
  
  # 4 Plots
  plot <- ggplot(merged_data, aes(x = beta_std, y = Effect)) +
    geom_point() + labs(x=paste0("beta (",cell.list[n],")"),
                        y="Effect (GoDMC)")
  
  plots_list[[n]] <- plot
}

results_df <- do.call(rbind, results_list)
results_df<-as.data.table(results_df)

prop_table_df <- do.call(rbind, prop_table_list)
prop_table_df <- as.data.table(prop_table_df)

repl_df <- do.call(rbind, repl_list)
repl_df <- as.data.table(repl_df)

##  r function for formatting p-values

format.pvalue <- function(x) {
  formatted.x <- ifelse(x > 0.01,
                        formatC(x, digits = 2, format = "f"),
                        formatC(x, digits = 0))
  return(formatted.x)
}
results_df[, PValue := format.pvalue(PValue)]
results_df[, Beta := formatC(Beta, digits = 4, format = "f")]
results_df[, SE := formatC(SE, digits = 4, format = "f")]

#Save the plot 
grid_plots <- grid.arrange(grobs = plots_list, ncol = 2, nrow = 2)
ggsave(filename = "/user/home/uy23281/scratch/rmd.results/model4/Effect_plot.png", plot = grid_plots)
```

```{r results_m4_df, echo=FALSE}
print(results_df)
#knitr::kable(results_df, format="latex",digits=5,booktabs=T,
#             col.names=c("Cell type","beta","SE","P-value"),align = "c",
#             caption='\\textbf{Linear model results for the relationship between GoDMC and #model 4 effects}')
```

### Overall replication rate
```{r prop_table_m4_df, echo=FALSE}
print(prop_table_df)
```

### Replication rate (observed vs expected)
```{r repl_m4_df, echo=FALSE}
print(repl_df)
```

### Plots
```{r plot2, out.width="80%", fig.align="center",fig.cap=c("GoDMC effect versus model 4 effect"), echo=FALSE}
knitr::include_graphics("/user/home/uy23281/scratch/rmd.results/model4/Effect_plot.png")

```

## Relationship between GoDMC and model 5 (bulk+int model) effects
```{r, include=FALSE}
##Loop to read and process all 100 chunks 
# Initialize an empty data frame to store the results
merged_data <- data.frame()
cell.list<-c("neu","mono","tcell","bcell")
#Create an empty list to store data frames and plots 
results_list <- list()
plots_list <- list()
prop_table_list <- list()
repl_list <- list()
#Loop through cell types
for (n in 1:length(cell.list)){
  # Read standard deviation file 
  sds<-read.table(paste0("/user/home/uy23281/scratch/rmd.results/model5/",cell.list[n],"/sd.methy.txt"),header=T,sep="\t")
  # Loop through 7 chunks of cell data
  for (i in 1:7) {
    # Read in the current chunk
    chunk_file <- paste0("/user/home/uy23281/scratch/rmd.results/model5/",cell.list[n],"/res.cis.", i, ".gz")
    cell <- fread(chunk_file)
    cell <- left_join(cell, sds, by = c("gene" = "cpg"))
    
    # Subset the current chunk based on the clumped$cpg values
    cell <- subset(cell, gene %in% clumped$cpg)
    
    # Separate SNP column into chr and pos
    cell <- cell  %>% tidyr::separate(SNP, sep = ":", into = c("chr", "pos"))
    
    # Separate pos column into pos, a1, and a2
    cell <- cell %>% tidyr::separate(pos, sep = "_", into = c("pos", "a1", "a2"))
    
    # Standardize cell data
    cell2 <- standardise(cell, "a1", "a2", "beta", "chr", "pos")
    
    # Merge with clumped2 data
    m <- inner_join(clumped2, cell2, by = c("snpid", "cpg" = "gene"))
    
    # Calculate standard error
    m$se <- m$beta / m$`t-stat`
    m$se_std<-m$se/m$sd
    m$beta_std<-m$beta/m$sd
    
    # Append the current chunk's data to the merged_data
    if (i == 1) {
      merged_data <- m
    } else {
      merged_data <- rbind(merged_data, m)
    }
  }
  # 1 Relationship between the effects
  full <- lm(Effect ~ beta_std, data = merged_data)
  fitted <- summary(full)$coefficients
  result_df <- data.frame(CellType = cell.list[n], Beta = fitted[2, 1], SE = fitted[2, 2],
                          PValue = fitted[2, 4])
  
  #2 Overall replication rate
  prop_table <- table(merged_data$`p-value` < 0.05) %>% prop.table()
  prop_table_df <- data.frame(CellType = cell.list[n], PropTable = prop_table)
  
  #3 Replication rate 
  repl <- repl_obs_exp(merged_data$Effect, merged_data$beta, merged_data$StdErr, merged_data$se_std, 5e-6)
  repl<-as.data.frame(repl$res)
  repl_df <- data.frame(CellType = cell.list[n], Repl = repl)
  
  #Save the different data frames 
  results_list[[n]] <- result_df
  prop_table_list[[n]] <- prop_table_df
  repl_list[[n]] <- repl_df
  
  # 4 Plots
  plot <- ggplot(merged_data, aes(x = beta_std, y = Effect)) +
    geom_point() + labs(x=paste0("beta (",cell.list[n],")"),
                        y="Effect (GoDMC)")
  
  plots_list[[n]] <- plot
}

results_df <- do.call(rbind, results_list)
results_df<-as.data.table(results_df)

prop_table_df <- do.call(rbind, prop_table_list)
prop_table_df <- as.data.table(prop_table_df)

repl_df <- do.call(rbind, repl_list)
repl_df <- as.data.table(repl_df)

##  r function for formatting p-values

format.pvalue <- function(x) {
  formatted.x <- ifelse(x > 0.01,
                        formatC(x, digits = 2, format = "f"),
                        formatC(x, digits = 0))
  return(formatted.x)
}
results_df[, PValue := format.pvalue(PValue)]
results_df[, Beta := formatC(Beta, digits = 4, format = "f")]
results_df[, SE := formatC(SE, digits = 4, format = "f")]

#Save the plot 
grid_plots <- grid.arrange(grobs = plots_list, ncol = 2, nrow = 2)
ggsave(filename = "/user/home/uy23281/scratch/rmd.results/model5/Effect_plot.png", plot = grid_plots)
```

```{r results_m5_df, echo=FALSE}
print(results_df)
#knitr::kable(results_df, format="latex",digits=5,booktabs=T,
#             col.names=c("Cell type","beta","SE","P-value"),align = "c",
#             caption='\\textbf{Linear model results for the relationship between GoDMC and #model 4 effects}')
```

### Overall replication rate
```{r prop_table_m5_df, echo=FALSE}
print(prop_table_df)
```

### Replication rate (observed vs expected)
```{r repl_m5_df, echo=FALSE}
print(repl_df)
```

### Plots
```{r plot3, out.width="80%", fig.align="center",fig.cap=c("GoDMC effect versus model 5 effect"), echo=FALSE}
knitr::include_graphics("/user/home/uy23281/scratch/rmd.results/model5/Effect_plot.png")

```


## Relationship between model 5 (bulk+int model) and model 4 (cell-sorted model)

